# 数组中重复的数字
[TOC]

## 一、题目要求
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

## 二、解题思路
### 2.1 排序
将数组中的元素进行排序，重复的元素会彼此相邻，只需要遍历的时候找出相邻且相等的元素即可
### 2.2 哈希表
遍历数组元素，将数组元素添加到哈希集合中，如果重复，会添加失败，即找到了重复元素
### 2.3 原地置换
遍历这个数组，当扫描到下标为i的元素（用`m`表示）时，比较`m`和数组下标`i`是否相同
+ 相同
    + 找到重复数组
+ 不相同
    + 把第i个数字和第`m`个数字交换，把`m`放到属于它的位置，重复交换过程，直到下标为`i`的元素等于`i`再对第`i+1`个元素进行相同的判断

## 三、代码

### 3.1 排序

```java
public int duplicate1(int[] nums) {
    if (nums == null || nums.length == 0) {
        return -1;
    }

    Arrays.sort(nums);

    int n = nums.length;
    for (int i = 1; i < n; ++i) {
        if (nums[i] == nums[i - 1]) {
            return nums[i];
        }
    }

    return -1;
}
```



分析：

+ 时间复杂度`O(nlogn)`
+ 空间复杂度`O(1)`



### 3.2 哈希表

```java
public int duplicate2(int[] nums) {
    if (nums == null || nums.length == 0) {
        return -1;
    }

    Set<Integer> set = new HashSet<>();

    int n = nums.length;
    for (int num : nums) {
        if (!set.add(num)) {
            return num;
        }
    }

    return -1;
}
```



分析：

+ 时间复杂度`O(n)`
+ 空间复杂度`O(n)`





### 3.3 原地置换

```java
public int duplicate3(int[] nums) {
    if (nums == null || nums.length == 0) {
        return -1;
    }

    int n = nums.length;
    for (int i = 0; i < n; ++i) {
        while (nums[i] != i) {
            if (nums[i] == nums[nums[i]]) {
                return nums[i];
            }

            // 必须先将nums[nums[i]]位置的元素换成nums[i]
            // 否则如果先交换nums[i]的值，会导致nums[nums[i]]定位的元素发生改变
            int temp = nums[nums[i]];
            nums[nums[i]] = nums[i];
            nums[i] = temp;
        }
    }

    return -1;
}
```



分析

+ 时间复杂度`O(n)`，尽管有一个嵌套的while循环，但每个数字最多交换两次就可以找到属于它的位置（第二次交换发现重复元素，直接返回），故时间复杂度还是O(n)

+ 空间复杂度`O(1)`